All Servers： 
• 如果 commitIndex > lastApplied：增加 lastApplied，将 log[lastApplied] 应用到状态机（§5.3） 
• 如果 RPC 请求或响应包含 term T > currentTerm：设置 currentTerm = T，转换为 follower（§5.1）

Followers（§5.2)： 
• 响应来自 candidates 和 leaders 的 RPC 
• 如果选举超时而没有收到来自当前 leader 的 AppendEntries RPC 或授予candidate投票：转换为 candidate

Candidates（§5.2）： 
• 转换为 candidate 时，开始选举： 
  • 递增 currentTerm 
  • 为自己投票 
  • 重置选举计时器 
  • 向所有其他服务器发送 RequestVote RPC 
• 如果从大多数服务器收到投票：成为 leader
• 如果从新 leader 收到 AppendEntries RPC：转换为 follower 
• 如果选举超时：开始新的选举

Leaders: 
• 选举时：向每个服务器发送初始的空 AppendEntries RPC（心跳）；在空闲期间重复以防止选举超时（§5.2）
• 如果从客户端收到命令：将 entry 附加到本地 log，在 entry 应用于状态机后做出响应（§5.3） 
• 如果 follower 的最后一个 logIndex ≥ nextIndex：发送 AppendEntries RPC 日志条目从 nextIndex 开始 
  • 如果成功：为 follower 更新 nextIndex 和 matchIndex（§5.3） 
  • 如果 AppendEntries 由于日志不一致而失败：减少 nextIndex 并重试（§5.3） 
• 如果存在 N 使得 N > commitIndex，则大多数 matchIndex[i] ≥ N，且 log[N].term == currentTerm：设置 commitIndex = N（§5.3，§5.4）


PS:
最好有一个长期运行的独立goroutine来使每个服务器在长时间未收到心跳时一起开始选举
选举超时可以用goroutine定期检查（用time.Sleep和一个小常量）

需要一个单独长时间运行的goroutin来发送在applyCh上按顺序提交的的日志条目（必须是单独的，在applyCh上发送会阻塞）

推进 commitIndex 的代码将需要踢apply goroutine；使用条件可能是最简单的变量（Go 的 sync.Cond）
RPC回复在同一个goroutine中处理（而不是通过channel回复）
RPC处理程序应该忽略旧term的RPC





140.82.112.4 github.com

151.101.1.194 github.global.ssl.fastly.net
151.101.65.194 github.global.ssl.fastly.net
151.101.129.194 github.global.ssl.fastly.net
151.101.193.194 github.global.ssl.fastly.net

185.199.108.153 assets-cdn.github.com
185.199.110.153 assets-cdn.github.com
185.199.111.153 assets-cdn.github.com
185.199.109.153 assets-cdn.github.com